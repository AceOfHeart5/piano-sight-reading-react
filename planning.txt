18th of May, 2023

Moving this app over to react/redux is not as drag and drop as I thought it'd be. Further more I'm pretty sure there's some crappy logic in the old design that I'd like to improve. So it's time to bust out a txt file to help organize thoughts and plan things out.

Let's start by describing how the old app worked as best we can. The key part is that the "music" is an array of chord objects, which store midi values for notes. The number of entries in the array is equal to the greatest number of notes per measure between the staffs (top and bottom) times the number of measures. So for example if there were 9 measures and the bottom staff was quarters notes and the top staff half notes, then the total number of entries in the array would be 36 (9 measures x 4 notes per measure bottom staff). A cursor keeps track of which index in the array the user is playing. Using navigator.requestMidiAccess, we can setup callbacks when the user plays a midi device. If a midi event contains the same values as the chord at the current index, then the cursor advances.

In addition to re-writing the above logic, we have to create random music generation in a logical way. We have to render the music to the DOM using abcjs, which requires a special string. Here's an example of a string generated by the old system:

T:
M:4/4
L:1/48
K:C
%%staves {1 2}
V:1
[K:C clef=treble]
[CC']12 D'12 D12 A12 |F'12 F'12 D12 F'12 |G12 F12 C'12 C'12 |F'12 G'12 C'12 G'12 |
V:2
[K:C clef=bass]
E,24 C24 |A,,24 C24 |F,24 F,24 |C24 C24 |
V:1
[K:C clef=treble]
D12 G'12 F'12 G'12 |C'12 F'12 D12 [CEF]12 |[CBC']12 F12 A12 [CGB]12 |C'12 E'12 D12 F12 |
V:2
[K:C clef=bass]
A,24 B,,24 |G,24 E,24 |C,24 A,24 |C,24 F,,24 |
V:1
[K:C clef=treble]
F12 E'12 F12 F'12 |D'12 G'12 E12 E12 |D12 E'12 F'12 D'12 |F'12 E'12 F12 B12 |
V:2
[K:C clef=bass]
G,24 A,,24 |C,24 A,24 |E,24 F,24 |C24 F,,24 |
V:1
[K:C clef=treble]
G12 D'12 E12 D12 |G'12 G12 G'12 A12 |F12 F'12 [CBC']12 E12 |D'12 E12 F'12 [CC']12 |
V:2
[K:C clef=bass]
B,,24 C24 |G,24 B,24 |A,,24 G,,24 |F,,24 E,24 |
V:1
[K:C clef=treble]
C'12 [CEA]12 C'12 A12 |B12 G'12 C'12 F'12 |B12 C'12 G'12 B12 |E'12 D12 G'12 B12 |]
V:2
[K:C clef=bass]
B,24 C,24 |F,,24 E,24 |A,24 A,24 |E,24 B,,24 |]

The above is ABC notation. We'll have to explore this site more later to make sure we understand what we're doing: https://abcnotation.com/

The main takeaway here is that we have to understand which notes are in the top staff, and which are in the bottom, in order to generate the above notation. So we can't simply generate the array we described above then derive the notation from that.

Unless perhaps we modify our chord object to keep track of which midi values are in the top staff, and which are in the bottom? This could work because we keep track of what duration the top/bottom staff notes should be in global state. We could simply grab all top/bottom staff notes from the array, then add notes to the generate string above with the currect duration.

However now I'm thinking about how precise this system should be. Does it make sense to create a data set that could represent any piece of music, even those without consistent durations? I like that idea because it lets us more easily expand this app in the future. Maybe users could create custom pieces of music to play through?

The first thing that throws me off about doing that is keeping track of when key or time signature changes. Our system would have to go measure by measure, and each measure would need its own time signature, key signature, set of bottom notes, and set of top notes. Additionally each note would have to keep track of its own duration. Now that I've described it to myself, I'm not against doing this because it sounds manageable. And I like the idea of our custom data containing so much information about the music by itself. I can imagine making a system that randomly generates this data, or allowing the user to create their own custom data.

Then, given this, I saw we proceed with making this custom music data, a way to track it in state, and a system of rendering it with abcjs. We could easily create dummy data that's just a bunch of quarter notes of the same note. Later we'll worry about creating logic to randomly generate it.

Quick note, I don't think using the entity adapter makes sense for most of this app. We don't have lot's of pieces of data that will be individuall updated, added, or removed.



31st of May, 2023

Need to get head on straight after the break. Last time we were considering how to store the music data. Since we committed to keeping track of changes in time/key signature, we'll have to store things measure by measure. I think we have a pretty straightforward strategy for storing data. Each measure will have 2 arrays of chords objects, one for bottom staff and one for top. It will also store the key and time signature of the measure.

The chords I'm a bit stumped by because I want to allow for correct accidentals. This means we can't only store the midi values of notes in the chords. We have to store the exact scale degree and any accidentals on it. But when it comes time to determine the exact midi value of a note, we'll need the key signature as well as the scale degree to find it. So, at least for now, we'll store pitch data as just scale degree, register, and accidental. 

Given this, a chord will be an array of pitch ojbects. The chord will also store duration, and we'll have a flag to determine if it's a rest or not. Or perhaps we should use an empty pitch array to signify the chord is a rest? Not sure, we'll worry about that later. I think I've got what I need to progress:

music state is an array of measures
measures store time/key signature and array of top and bottom staff chords
chords store duration and array of pitches
pitches store scale degree, register, and accidentals

Ah, but I want to think a little bit more about how we're handling duration. Since we want a cursor to be able to essentially "iterate" over the notes, we need a way to connect the duration of the top staff notes to the bottom. In our old system we simply set a "resolution" for each measure. I think it was 192 because it accomodated many divisions of 4 and 3. This way we could be sure the same number referenced the same spot in both the top and bottom staff array. And there would be empty spots in the array after each note to indicate its duration. Although that system would work here, I dislike it because it doesn't accomodate all possible rhythm combinations, and it feels ugly to have two different concepts represent duration of a note.

Ugh, ya know what let's just do that for now. I can't think of a better system atm, and honestly we'll probably never revisit this since it's more of a portfolio piece. Let's say eigth notes have a value of 12 (since that should cover most common values), which gives quarters a value of 24, and regular 4/4 measures a whole value of 96. We'll adjust these values if I find something wrong. 