18th of May, 2023

Moving this app over to react/redux is not as drag and drop as I thought it'd be. Further more I'm pretty sure there's some crappy logic in the old design that I'd like to improve. So it's time to bust out a txt file to help organize thoughts and plan things out.

Let's start by describing how the old app worked as best we can. The key part is that the "music" is an array of chord objects, which store midi values for notes. The number of entries in the array is equal to the greatest number of notes per measure between the staffs (top and bottom) times the number of measures. So for example if there were 9 measures and the bottom staff was quarters notes and the top staff half notes, then the total number of entries in the array would be 36 (9 measures x 4 notes per measure bottom staff). A cursor keeps track of which index in the array the user is playing. Using navigator.requestMidiAccess, we can setup callbacks when the user plays a midi device. If a midi event contains the same values as the chord at the current index, then the cursor advances.

In addition to re-writing the above logic, we have to create random music generation in a logical way. We have to render the music to the DOM using abcjs, which requires a special string. Here's an example of a string generated by the old system:

T:
M:4/4
L:1/48
K:C
%%staves {1 2}
V:1
[K:C clef=treble]
[CC']12 D'12 D12 A12 |F'12 F'12 D12 F'12 |G12 F12 C'12 C'12 |F'12 G'12 C'12 G'12 |
V:2
[K:C clef=bass]
E,24 C24 |A,,24 C24 |F,24 F,24 |C24 C24 |
V:1
[K:C clef=treble]
D12 G'12 F'12 G'12 |C'12 F'12 D12 [CEF]12 |[CBC']12 F12 A12 [CGB]12 |C'12 E'12 D12 F12 |
V:2
[K:C clef=bass]
A,24 B,,24 |G,24 E,24 |C,24 A,24 |C,24 F,,24 |
V:1
[K:C clef=treble]
F12 E'12 F12 F'12 |D'12 G'12 E12 E12 |D12 E'12 F'12 D'12 |F'12 E'12 F12 B12 |
V:2
[K:C clef=bass]
G,24 A,,24 |C,24 A,24 |E,24 F,24 |C24 F,,24 |
V:1
[K:C clef=treble]
G12 D'12 E12 D12 |G'12 G12 G'12 A12 |F12 F'12 [CBC']12 E12 |D'12 E12 F'12 [CC']12 |
V:2
[K:C clef=bass]
B,,24 C24 |G,24 B,24 |A,,24 G,,24 |F,,24 E,24 |
V:1
[K:C clef=treble]
C'12 [CEA]12 C'12 A12 |B12 G'12 C'12 F'12 |B12 C'12 G'12 B12 |E'12 D12 G'12 B12 |]
V:2
[K:C clef=bass]
B,24 C,24 |F,,24 E,24 |A,24 A,24 |E,24 B,,24 |]

The above is ABC notation. We'll have to explore this site more later to make sure we understand what we're doing: https://abcnotation.com/

The main takeaway here is that we have to understand which notes are in the top staff, and which are in the bottom, in order to generate the above notation. So we can't simply generate the array we described above then derive the notation from that.

Unless perhaps we modify our chord object to keep track of which midi values are in the top staff, and which are in the bottom? This could work because we keep track of what duration the top/bottom staff notes should be in global state. We could simply grab all top/bottom staff notes from the array, then add notes to the generate string above with the currect duration.

However now I'm thinking about how precise this system should be. Does it make sense to create a data set that could represent any piece of music, even those without consistent durations? I like that idea because it lets us more easily expand this app in the future. Maybe users could create custom pieces of music to play through?

The first thing that throws me off about doing that is keeping track of when key or time signature changes. Our system would have to go measure by measure, and each measure would need its own time signature, key signature, set of bottom notes, and set of top notes. Additionally each note would have to keep track of its own duration. Now that I've described it to myself, I'm not against doing this because it sounds manageable. And I like the idea of our custom data containing so much information about the music by itself. I can imagine making a system that randomly generates this data, or allowing the user to create their own custom data.

Then, given this, I saw we proceed with making this custom music data, a way to track it in state, and a system of rendering it with abcjs. We could easily create dummy data that's just a bunch of quarter notes of the same note. Later we'll worry about creating logic to randomly generate it.

Quick note, I don't think using the entity adapter makes sense for most of this app. We don't have lot's of pieces of data that will be individuall updated, added, or removed.



31st of May, 2023

Need to get head on straight after the break. Last time we were considering how to store the music data. Since we committed to keeping track of changes in time/key signature, we'll have to store things measure by measure. I think we have a pretty straightforward strategy for storing data. Each measure will have 2 arrays of chords objects, one for bottom staff and one for top. It will also store the key and time signature of the measure.

The chords I'm a bit stumped by because I want to allow for correct accidentals. This means we can't only store the midi values of notes in the chords. We have to store the exact scale degree and any accidentals on it. But when it comes time to determine the exact midi value of a note, we'll need the key signature as well as the scale degree to find it. So, at least for now, we'll store pitch data as just scale degree, register, and accidental. 

Given this, a chord will be an array of pitch ojbects. The chord will also store duration, and we'll have a flag to determine if it's a rest or not. Or perhaps we should use an empty pitch array to signify the chord is a rest? Not sure, we'll worry about that later. I think I've got what I need to progress:

music state is an array of measures
measures store time/key signature and array of top and bottom staff chords
chords store duration and array of pitches
pitches store scale degree, register, and accidentals

Ah, but I want to think a little bit more about how we're handling duration. Since we want a cursor to be able to essentially "iterate" over the notes, we need a way to connect the duration of the top staff notes to the bottom. In our old system we simply set a "resolution" for each measure. I think it was 192 because it accomodated many divisions of 4 and 3. This way we could be sure the same number referenced the same spot in both the top and bottom staff array. And there would be empty spots in the array after each note to indicate its duration. Although that system would work here, I dislike it because it doesn't accomodate all possible rhythm combinations, and it feels ugly to have two different concepts represent duration of a note.

Ugh, ya know what let's just do that for now. I can't think of a better system atm, and honestly we'll probably never revisit this since it's more of a portfolio piece. Let's say eigth notes have a value of 12 (since that should cover most common values), which gives quarters a value of 24, and regular 4/4 measures a whole value of 96. We'll adjust these values if I find something wrong. 

I'm realizing I'm not exactly sure how to handle random pitch selection. We need a way to cap what pitches we select from. But since our pitch object works using scale degree, we can't use a pitch object since that changes based on the chosen key signature. I think we need to instead store a pitch class and register for capping random selection.


1st of June, 2023

Still thinking on how to handle random pitch generation. We created a separate type to represent a pitch cap since it's a slightly different idea than a pitch within a key signature. The pitch cap is just a register and class, where as an actual pitch is a scale degree and register. I have an idea of creating an array of possible pitches given a scale degree, then removing ones that don't fit within the given caps. The trick with this is determining if a pitch is above/below a cap. I'm willing to bet we can worry about that logic later.

At the moment I'm actually distracted by displaying this data. Let's add the start of the random music generation logic just as comments, then focus on making the music displayable using dummy data.

I have a new idea about caps for pitches, let's just use an actual pitch. Originally I wanted to keep the idea of caps and pitches separate so that users could choose a spot on the staff as their cap, instead of a specific pitch from the key. Otherwise I'd probably have to repopulate the cap list with pitches from the key evertime the user changed keys. Except I just realized that's not hard at all, and in-fact I think that's a clearer and better way to do it!


2nd of June, 2023

I've realized I haven't thought out how I'm going to determine number of measures per line, or how we'll iterate over them to determine what the actual sheet music looks like.


5th of June, 2023

I was going to write out how I was going to generate the abc string, but I managed to write some code anyway.


6th of June, 2023

Last time we were working on finishing the abc js string creation. And to do that we decided to make a hard coded mapping of key signatures, scale degress, midi values and pitch classes. This way we also have easy access to the pitch class of a given pitch (which we need for notation). When we last looked at this we realized we needed to create each line staff by staff because of how abc notation works. We'll with our strategy from yesterday.

We just added a small function to convert a pitch to an abc pitch. However it's not finished because it doesn't account for accidentals. That could be annoying since we'll have to determine the "natural" accidental on the pitch based on the key, and determine if we should use a natural/flat/sharp to adjust it based on that. But for now let's just see if this function works well enough to keep moving forward.

Turns out we had some flaws in our logic for determining how many measures should be on 1 line. Firstly, I realized it won't actually be that hard to make a function with returns the width of a given measure. We'll have to use some magic numbers for this, but given that music notes are fixed size things regardless of screen size I think this is fine.

Ah, a self note about some logic that I couldn't wrap my head around before. We use the width of the page and the width of measures to determine how many measures there are per line. But we never calculate how many lines there are. Instead we use the height of the page, and the probable width of measures to determine how many measures there should be.